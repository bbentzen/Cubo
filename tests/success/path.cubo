/*
 * Copyright (c) 2019 Bruno Bentzen. All rights reserved.
 * Released under the Apache License 2.0 (see "License");
 * Author: Bruno Bentzen
 */
   
/* Path type */
 
def rfl {A : type 1} {a : A} 
⊢ path A a a :=
<_> a
 
def pathd_abs {A : I → type 1} (p : Π (i : I) app A i)
⊢ pathd A (app p i0) (app p i1) :=
<i> app p i
 
def pathd_app {A : I → type 1} (a : app A i0) (b : app A i1) (p : pathd A a b)
⊢ Π (i : I) app A i :=
λ i, p @ i
 
def id_endpt_1 {A : type 1} {B : A → type 1} {a b : A} (p : path A a b) (x : app B (p @ i0)) (y : app B (p @ i1))
⊢ app B a × app B b :=
(x, y)
 
def id_endpt_2 {A : type 1} {B : A → type 1} {a b : A} (p : path A a b) (x : app B a) (y : app B b)
⊢ app B (p @ i0) × app B (p @ i1) :=
(x, y)
 
def ap {A B : type 1} (f : A → B) {a b : A} 
⊢ path A a b → path B (app f a) (app f b) :=
λp, <i> app f (p @ i)
 
def apd {A : type 1} {B : A → type 1} (f : Π (x : A) app B x) {a b : A} (p : pathd (λi, A) a b)
⊢ pathd (λi, app B (p @ i)) (app f a) (app f b) :=
<i> app f (p @ i)
 
def funext {A : type 1} {B : A → type 1} (f g : Π (x : A) app B x) 
⊢ (Π (x : A) path (app B x) (app f x) (app g x)) → path (Π (x : A) app B x) f g :=
λh, <i> (λ x, (app h x) @ i)
 
/** Proof irrevelance **/

def irrel_uip {A : type 1} {a b : A} (p q : path A a b)
⊢ path (path A a b) p q :=
<_> p
 
def irrel_line {A : type 1} {a b : A} (p q : path A a b)
⊢ path (Π (x : I) A) (λ i, p @ i) (λ j, q @ j) :=
<_> (λ i, p @ i)
 
def irrel_k {A : type 1} {a : A} (p : path A a a)
⊢ path (path A a a) p (<_> a) :=
<_> p
 
def irrel_example {A : type 1} {a b : A} {B : path A a b → (Π (x : I) A) → type 1} (p q : path A a b) 
⊢ app app B p (λ i, p @ i) →  app app B q (λ j, q @ j) :=
λ x, x
 
def irrel_example2 {A : type 1} (i j : I) {a b : A} (p q : I → path A a b)
⊢ path (path A a b) (app p i) (app q j) :=
<_> app p i

 
/** TODO: for the code-encode method (bool, sums, nat) we need coercion **/

