/* theorems which are correctly type checked */

/* function type */

def id {A : type 1}
⊢ A → A :=
λ x, x
 
def iff_id {A : type 1}
⊢ A ↔ A :=
(id, id)

def k_combinator (A B : type 1)
⊢ A → B → A :=
λx, λy, x
 
def s_combinator (A B C : type 1)
⊢ (A → B → C) → (A → B) → (A → C) :=
λf, λg, λx, app (app f x) (app g x)
 
def b_combinator (A B C : type 1)
⊢ (B → C) → (A → B) → (A → C) :=
λf, λg, λx, app f (app g x)
 
def arg_exg (A B C : type 1)
⊢ (A → B → C) → (B → A → C) :=
λf, λy, λx, app (app f x) y
 
def w_combinator (A B : type 1) 
⊢ (A → A → B) → (A → B) :=
λf, λx, app (app f x) x
 
def comp (A B C : type 1) 
⊢ (A → B) → (B → C) → (A → C) :=
λf, λg, λx, app g (app f x)
 
/* Negation & Empty type */
 
def not_false
⊢ ¬ void :=
λx, x
 
def dni (A : type 1)
⊢ A → ¬¬A :=
λx, λf, app f x
 
def tne (A : type 1)
⊢ ¬¬¬A → ¬A :=
λf, λx, app f (λnx, app nx x)
 
def contrap (A B : type 1)
⊢ (A → B) → (¬ B → ¬ A) :=
λf, λg, λx, app g (app f x)
 
def neg_distr (A B : type 1)
⊢ ¬ (A → B) → (A → ¬ B) :=
λf, λ_, λy, app f (λ_, y)
 
def neg_ant (A B : type 1)
⊢ (A → B) → (A → ¬ B) → ¬ A :=
λ f, λ g, (λ x, app (app g x) (app f x))
 
def ex_falso (A B : type 1)
⊢ A → ¬ A → B :=
λ x, λ f, abort (app f x)
 
/* Product type */
 
def pr1 (A B : type 1)
⊢ (A × B) → A :=
λ w, fst w
 
def pr2 (A B : type 1)
⊢ (A × B) → B :=
λ w, snd w
 
def pair (A B : type 1)
⊢ A → B → A × B :=
λ x, λ y, (x, y)
 
def prod_swap (A B : type 1)
⊢ (A × B) → (B × A) :=
λ w, (snd w, fst w)
 
def prod_assoc (A B C : type 1)
⊢ A × B × C ↔ (A × B) × C :=
(λ w, ((fst w, fst (snd w)), snd (snd w)),
 λ w, (fst (fst w), (snd (fst w), snd w)))
 
def prod_distrib_fst (A B C : type 1)
⊢ ((A → C) × (B → C)) → ((A × B) → C) :=
λ w1, λ w2, app (fst w1) (fst w2)
 
def prod_distrib_snd (A B C : type 1)
⊢ ((A → C) × (B → C)) → ((A × B) → C) :=
λ w1, λ w2, app (snd w1) (snd w2)
 
def curry (A B C : type 1)
⊢ ((A × B) → C) → (A → B → C) :=
λ f, (λ x, λ y, app f (x, y))
 
def cocurry (A B C : type 1)
⊢ (A → (B × C)) → (A → B → C) :=
λ f, (λ x, λ _, snd (app f x))
 
def lnc (A B : type 1)
⊢ ¬ (A × ¬A) :=
λ f, app (snd f) (fst f)
 
def prod_up (A B C : type 1)
⊢ (C → A × B) ↔ (C → A) × (C → B) :=
(λ f, (λ x, fst (app f x), λ x, snd (app f x)),
 λ w, λ x, (app (fst w) x, app (snd w) x))
 
def fun_to_neg_prod (A B : type 1)
⊢ (A → B) → ¬ (A × ¬ B) :=
λ f, λ w, app (snd w) (app f (fst w))
 
def neg_fun_to_neg_prod (A B : type 1)
⊢ (A → ¬B) → ¬(A × B) :=
λ f, λ w, app (app f (fst w)) (snd w)
 
def neg_prod_to_neg_fun (A B : type 1)
⊢ ¬(A × B) → (A → ¬B) :=
λ f, λ x, λ y, app f (x,y)
 
def prod_to_neg_fun_1 (A B : type 1)
⊢ (A × B) → ¬(A → ¬B) :=
λ w, λ f, app (app f (fst w)) (snd w)
 
/* Sum type */
 
def de_morgan_prod_1 (A B : type 1)
⊢ (A × B) → ¬ (¬A + ¬B) :=
λ w, λ v, case v (λ f, app f (fst w)) (λ g, app g (snd w))
 
def de_morgan_prod_2 (A B : type 1)
⊢  (¬ A × ¬ B) → ¬ (A + B) :=
λ w, λ v, case v (λ x, app (fst w) x) (λ y, app (snd w) y)
 
def prod_elim_sum (A B C : type 1)
⊢  (A × B) → ((A → C) + (B → C)) → C :=
λ w, λ v, case v (λ f, app f (fst w)) (λ g, app g (snd w))
 
def weak_1 (A B : type 1)
⊢ A → A + B :=
λ x, inl x
 
def weak_2 (A B : type 1)
⊢ B → A + B :=
λ y, inr y
 
def sum_swap (A B : type 1) 
⊢ (A + B) → (B + A) :=
λ v, case v (λ x, inr x) (λ y, inl y)
 
def sum_assoc (A B C : type 1) 
⊢ (A + B + C) ↔ ((A + B) + C) :=
(λ v1, case v1 (λ x, inl (inl x)) (λ v2, case v2 (λ y, inl (inr y)) (λ z, inr z)),
 λ v1, case v1 (λ v2, case v2 (λ x, inl x) (λ y, inr (inl y))) (λ z, inr (inr z)))
 
def sum_distrib_1 (A B C : type 1) 
⊢ ((A + B) → C) → ((A → C) + (B → C)) :=
λ f, inl (λ x, app f (inl x))
 
def sum_distrib_2 (A B C : type 1) 
⊢ ((A + B) → C) → ((A → C) + (B → C)) :=
λ f, inr (λ y, app f (inr y))
 
def disj_syll_1 (A B C : type 1) 
⊢ (A + B) → (¬A) -> B  :=
λ v, λ f, case v (λ x, abort (app f x)) (λ y, y)
 
def disj_syll_2 (A B : type 1)
⊢ (A + B) → (¬B) → A  :=
λ v, λ g, case v (λ x, x) (λ y, abort (app g y))
 
def not_not_lem (A : type 1)
⊢ ¬¬ (A + ¬A) :=
λ f, app f (inr (λ x, app f (inl x)))
 
def lem_implies_dne (A : type 1) (lem : A + ¬A)
⊢ ¬¬A → A :=
λ f, case lem (λ x, x) (λ nx, abort (app f nx))
 
def dne_implies_lem (A : type 1) (dne : ¬¬(A + ¬A) → (A + ¬A))
⊢ A + ¬A :=
app dne (λ f, app f (inr (λ x, app f (inl x))))
 
def sum_up_1 (A B C : type 1)
⊢ (A → C) → (B → C) → ((A + B) → C) :=
λ f, λ g, λ v, case v f g
 
def sum_up_2 (A B C : type 1)
⊢ ((A + B) → C) → (A → C) :=
λ f, λ x, app f (inl x)
 
def sum_up_3 (A B C : type 1)
⊢ ((A + B) → C) → (B → C) :=
λ f, λ y, app f (inr y) 
 
def sum_to_fun (A B : type 1)
⊢ (A + B) → (¬ A → B) :=
λ v, case v (λ x, (λ f, abort (app f x))) (λ y, λ f, y)
 
def sum_neg_to_fun (A B : type 1)
⊢ (¬ A + B) → (A → B) :=
λ v, λ x, case v (λ nx, abort (app nx x)) (λ y, y)
 
def de_morgan_sum_1 (A B : type 1)
⊢ (A + B) → ¬ (¬ A × ¬ B) :=
λ v, λ w, case v (λ x, app (fst w) x) (λ y, app (snd w) y)
 
def de_morgan_sum_2 (A B : type 1)
⊢ ¬(A + B) → (¬A × ¬B) :=
λ f, (λ x, app f (inl x) , λ y, app f (inr y))
 
def de_morgan_sum_3 (A B : type 1)
⊢ (¬ A + ¬ B) → (¬ (A × B)) :=
λ v, λ w, case v (λ f, app f (fst w)) (λ g, app g (snd w)) 
 
def sum_elim (A B C : type 1)
⊢ (A + B) → ((A → C) × (B → C)) → C :=
λ v, λ f, case v (λ x, app (fst f) x) (λ y, app (snd f) y)
 
/* unit */

def lem_unit
⊢ unit + ¬unit :=
inl ()
 
def unit_to_bool
⊢ (unit + unit) → bool :=
λ v, case v (λ u, let u true) (λ u, let u false)
 
theorem bool_to_unit
⊢ bool → (unit + unit) :=
λ b, if b (inl ()) (inr ())
 
/* Boolean */
 
definition bneg
⊢ bool → bool :=
λ b, if b false true
 
definition band
⊢ bool → bool → bool :=
λ b1, λ b2, if b1 (if b2 true false) (if b2 false false)
 
definition bor
⊢ bool → bool → bool :=
λ b1, λ b2, if b1 (if b2 true true) (if b2 true false)
 
definition bimpl
⊢ bool → bool → bool :=
λ b1, λ b2, if b1 (if b2 true false) (if b2 true true)
 
definition bnand
⊢ bool → bool → bool :=
λ b1, λ b2, if b1 (if b2 false true) (if b2 true true)
 
definition bnor
⊢ bool → bool → bool :=
λ b1, λ b2, if b1 (if b2 false false) (if b2 false true)
 
/* Natural numbers */
 
definition pred
⊢ nat → nat :=
λ n, natrec n 0 (λ k, λ _, k)
 
definition add
⊢ nat → nat → nat :=
λ m, λ n, natrec n m (λ k, λ f, succ f)
 
definition mult 
⊢ nat → nat → nat := 
λ m, λ n, natrec n 0 (λ k, λ f, (natrec f m (λ k, λ g, succ g)))
 
/* Dependent function type */
 
def dcombinator_s (A : type 1) (B C : A → type 1)
⊢ (Π (x : A) app B x → app C x) → (Π (x : A) app B x) → (Π (x : A) app C x) :=
λ f, λ g, λ x, app (app f x) (app g x)
 
theorem pi_comm (A : type 1) (B : A → A → type 1)
⊢ (Π (x : A) Π (y : A) app (app B x) y) → Π (y : A) Π (x : A) (app (app B x) y) :=
λ f, λ y, λ x, app (app f x) y
 
/* if pi-fun1 and 2 are together, weird bug happens! **/
 
theorem pi_fun_distr1 (A B : type 1) (C : A → type 1)
⊢ (B → (Π (x : A) app C x)) → (Π (x : A) (B → app C x)) :=
λ f, λ y, λ x, app (app f x) y
 
theorem pi_fun_distr2 (A B : type 1) (C : A → type 1)
⊢ (Π (x : A) (B → app C x)) → (B → (Π (x : A) app C x)) :=
λ f, λ y, λ x, app (app f x) y
 
theorem dprod_up_2_fst (A : type 1) (B C : A → type 1)
⊢ (Π (x : A) app B x × app C x) → (Π (x : A) app B x) :=
λ f, λ x, fst (app f x)
 
theorem dprod_up_2_snd (A : type 1) (B C : A → type 1)
⊢ (Π (x : A) app B x × app C x) → (Π (x : A) app C x) :=
λ f, λ x, snd (app f x)
 
theorem pi_prod_distr (A B : type 1) (C : A → type 1)
⊢ (B × Π (x : A) app C x) → (Π (x : A) B × app C x) :=
λ w, λ x, (fst w, app (snd w) x)
 
theorem pi_sum_distr (A : type 1) (B C : A → type 1)
⊢ ((Π (x : A) app B x) + (Π (x : A) app C x)) → (Π (x : A) app B x + app C x) :=
λ w, λ x, case w (λ f, inl (app f x)) (λ g, inr (app g x))
 
theorem pi_sum_distrb (A B : type 1) (C : A → type 1)
⊢ (B + (Π (x : A) app C x)) → (Π (x : A) B + app C x) :=
λ w, λ x, case w (λ y, inl y) (λ f, inr (app f x))
 
theorem dcase (A B : type 1) (C : (A + B) → type 1) (f : Π (x : A) app C (inl x)) (g : Π (y : B) app C (inr y))
⊢ Π (x : A + B) app C x :=
λ v, case v f g
 
theorem dlet (C : unit → type 1) (c : app C ())
⊢ Π (x : unit) app C x :=
λ u, let u c
 
theorem dif (C : bool → type 1) (c1 : app C true) (c2 : app C false)
⊢ Π (x : bool) app C x :=
λ b, if b c1 c2
 
theorem dnatrec (C : nat → type 1) (c0 : app C 0) (cs : Π (n : nat) app C n → app C (succ n))
⊢ Π (n : nat) app C n :=
λ n, natrec n c0 cs
 
/* Dependent product type */
 
theorem sigma_intro (A B : type 1) (C : A → type 1) (a : A) (u : app C a)
⊢ Σ (x : A) app C x :=
(a, u)
 
theorem sigma_prod_distrb1 (A B : type 1) (C : A → type 1)
⊢ (B × Σ (x : A) app C x) → Σ (x : A) (B × app C x) :=
λ w, (fst (snd w), (fst w, snd (snd w)))
 
theorem sigma_prod_distrb2 (A B : type 1) (C : A → type 1)
⊢ (Σ (x : A) (B × app C x)) → (B × Σ (x : A) app C x) :=
λ w, (fst (snd w), (fst w, snd (snd w)))
 
theorem sigma_sum_distrb (A B : type 1) (C : A → type 1)
⊢ (Σ (x : A) B + app C x) → (B + Σ (x : A) app C x) :=
λ w, case (snd w) (λ x, inl x) (λ y, inr (fst w, y))
 
theorem sigma_prod_distrb (A : type 1) (B C : A → type 1)
⊢ (Σ (x : A) app B x × app C x) → (Σ (x : A) app B x) × (Σ (x : A) app C x) :=
λ w, ((fst w, fst (snd w)), (fst w, snd (snd w)))
 
theorem pi_to_not_sigma (A B : type 1) (C : A → type 1)
⊢ (Π  (x : A) app C x) → ¬(Σ (x : A) ¬app C x) :=
λ f, λ w, app (snd w) (app f (fst w))
 
theorem pi_not_to_not_sigma (A B : type 1) (C : A → type 1)
⊢ (Π  (x : A) ¬app C x) → ¬(Σ (x : A) app C x) :=
λ f, λ w, app (app f (fst w)) (snd w)
 
theorem sigma_to_not_pi  (A B : type 1) (C : A → type 1)
⊢ (Σ (x : A) app C x) → ¬(Π (x : A) ¬app C x) :=
λ w, λ f, app (app f (fst w)) (snd w)
 
theorem not_sigma_to_pi_not (A B : type 1) (C : A → type 1)
⊢ (¬(Σ (x : A) app C x)) → (Π (x : A) ¬ app C x) :=
λ f, λ x, λ c, app f (x, c)
 
theorem sigma_not_to_not_pi  (A : type 1) (C : A → type 1)
⊢ (Σ (x : A) ¬ app C x) → ¬ (Π  (x : A) app C x) :=
λ w, λ f, app (snd w) (app f (fst w))
 
theorem sigma_pi_exchg (A B : type 1) (C : A → B → type 1)
⊢ (Σ (x : A) (Π  (y : B) app (app C x) y)) -> (Π  (y : B) (Σ (x : A) app (app C x) y)) :=
λ w, λ y, (fst w, app (snd w) y)
 
/* Universes */
 
def pathd_type (A : I → type 1) (p : Π (i : I) app A i)
⊢ type 1 :=
pathd A (app p i0) (app p i1)
 
/* path type */
 
def rfl (A : type 1) (a : A) 
⊢ path A a a :=
<_> _
 
def pathd_abs (A : I → type 1) (p : Π (i : I) app A i)
⊢ pathd A (app p i0) (app p i1) :=
<i> app p i
 
def pathd_app (A : I → type 1) (a : app A i0) (b : app A i1) (p : pathd A a b)
⊢ Π (i : I) app A i :=
λ i, p @ i
 
def id_endpt_1 (A : type 1) (B : A → type 1) (a b : A) (p : path A a b) (x : app B (p @ i0)) (y : app B (p @ i1))
⊢ app B a × app B b :=
(x, y)
 
def id_endpt_2 (A : type 1) (B : A → type 1) (a b : A) (p : path A a b) (x : app B a) (y : app B b)
⊢ app B (p @ i0) × app B (p @ i1) :=
(x, y)
 
def ap (A B : type 1) (f : A → B) (a b : A) 
⊢ path A a b → path B (app f a) (app f b) :=
λp, <i> app f (p @ i)
 
def apd (A : type 1) (B : A → type 1) (f : Π (x : A) app B x) (a b : A) (p : pathd (λi, A) a b)
⊢ pathd (λi, app B (p @ i)) (app f a) (app f b) :=
<i> app f (p @ i)
 
def funext (A : type 1) (B : A → type 1) (f g : Π (x : A) app B x) 
⊢ (Π (x : A) path (app B x) (app f x) (app g x)) → path (Π (x : A) app B x) f g :=
λh, <i> (λ x, (app h x) @ i)
 
/* path structure of types */
 
definition add_zero (m : nat)
⊢ path nat (app (app add 0) m) m :=
natrec m (<_> 0) (λ n, λ p , <i> succ (p @ i))

def bneg_inv (b : bool)
⊢ path bool (app bneg (app bneg b)) b :=
if b (<i> true) (<i> false)
 
def band_comm (b1 b2 : bool)
⊢ path bool (app (app band b1) b2) (app (app band b2) b1) :=
if b1 (if b2 (<_> true) (<_> false)) (if b2 (<_> false) (<_> false))
 
def band_assoc (b1 b2 b3 : bool)
⊢ path bool (app (app band b1) (app (app band b2) b3)) (app (app band (app (app band b1) b2)) b3) :=
if b1 
  (if b2 (if b3 (<_> true) (<_> false)) (if b3 (<_> false) (<_> false))) 
  (if b2 (if b3 (<_> false) (<_> false)) (if b3 (<_> false) (<_> false)))
 
def bor_comm (b1 b2 : bool)
⊢ path bool (app (app bor b1) b2) (app (app bor b2) b1) :=
if b1 (if b2 (<_> true) (<_> true)) (if b2 (<_> true) (<_> false))
 
def bor_assoc (b1 b2 b3 : bool)
⊢ path bool (app (app bor b1) (app (app bor b2) b3)) (app (app bor (app (app bor b1) b2)) b3) :=
if b1 
  (if b2 (if b3 (<_> true) (<_> true)) (if b3 (<_> true) (<_> true))) 
  (if b2 (if b3 (<_> true) (<_> true)) (if b3 (<_> true) (<_> false)))
 
def pair_eq (A B : type 1) (a a' : A) (b b' : B)
⊢ path A a a' × path B b b' ↔ path (A × B) (a, b) (a', b') :=
(λ w, <i> (fst w @ i, snd w @ i),
 λ p, (<i> fst (p @ i), <j> snd (p @ j)))

def unit_eq (u : unit)
⊢ path unit u () :=
let u (<_> ())
 
/** TODO: for the code-encode method (bool, sums, nat) we need coercion **/

